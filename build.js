// build.js
const fs = require('fs');
const path = require('path');
const pako = require('pako');

console.log('Preparing and compressing esbuild.wasm for bundling...');

// 1. Find the esbuild.wasm file.
const wasmPath = require.resolve('esbuild-wasm/esbuild.wasm');

// 2. Read the Wasm file's binary content.
const wasmBytes = fs.readFileSync(wasmPath);

// 3. Compress the Wasm binary using zlib (DEFLATE).
// This is the key step for size reduction.
const compressedWasmBytes = pako.deflate(wasmBytes, { level: 9 }); // Level 9 for max compression

// 4. Define the path for the generated JS module.
const outputPath = path.join(__dirname, 'src', 'esbuild-wasm.js');

// 5. Create the JavaScript module content.
// This module now exports the COMPRESSED data and the decompression logic.
const jsContent = `
// This file is generated by build.js. Do not edit.
import pako from 'pako';

// 1. The compressed esbuild.wasm binary data as a Uint8Array.
const compressedWasm = new Uint8Array([${compressedWasmBytes.join(',')}]);

// 2. Decompress the data and then compile it into a WebAssembly.Module.
//    This happens once when the module is first imported.
const wasmModule = WebAssembly.compile(pako.inflate(compressedWasm));

// 3. Export the promise that resolves to the compiled module.
export default wasmModule;
`;

// 6. Write the generated module to the src directory.
fs.writeFileSync(outputPath, jsContent);

console.log(`Compressed esbuild.wasm has been prepared at: ${outputPath}`);
