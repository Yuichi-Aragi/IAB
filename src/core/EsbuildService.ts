/**
 * @file Manages the lifecycle of the esbuild WebAssembly service.
 *       This service is responsible for initializing the bundled esbuild-wasm
 *       and providing a stable API to the rest of the plugin.
 */

import { App, Notice } from 'obsidian';
import { EsbuildAPI } from '../types';
import { Logger } from '../utils/Logger';
import { EsbuildInitializationError, PluginError, createChainedMessage } from '../errors/CustomErrors';
import { container, ServiceTokens } from '../utils/DIContainer';
import { EventBus } from '../services/EventBus';
import { EsbuildStatus } from '../types/events';

// Import the esbuild API from the wasm package
import * as esbuild from 'esbuild-wasm';
// Import the pre-compiled Wasm module generated by our build.js script.
// This module now handles its own decompression internally.
import wasmModulePromise from '../esbuild-wasm.js';

export class EsbuildService {
    private readonly logger: Logger;
    private readonly eventBus: EventBus;

    // --- State Management ---
    private status: EsbuildStatus = 'uninitialized';
    private initializationPromise: Promise<void> | null = null;
    private lastInitializationError: EsbuildInitializationError | null = null;

    constructor(app: App) {
        // Cache service instances to prevent resolution errors during unload.
        this.logger = container.resolve<Logger>(ServiceTokens.Logger);
        this.eventBus = container.resolve<EventBus>(ServiceTokens.EventBus);
    }

    // --- Public API ---

    public getEsbuildAPI(): EsbuildAPI | null {
        // The esbuild API is now a direct import, but we only return it if initialized.
        return this.status === 'initialized' ? esbuild : null;
    }

    public isInitialized(): boolean {
        return this.status === 'initialized';
    }

    public isInitializing(): boolean {
        return this.status === 'initializing';
    }

    public getLastInitializationError(): EsbuildInitializationError | null {
        return this.lastInitializationError;
    }

    public initializeEsbuild(initiatorId: string = 'Unknown'): Promise<void> {
        const logPrefix = `[EsbuildInit:${initiatorId}]`;
        this.logger.log('info', `${logPrefix} Initialization requested.`);

        if (this.status === 'initialized') {
            this.logger.log('info', `${logPrefix} Esbuild already initialized. Resolving immediately.`);
            return Promise.resolve();
        }

        if (this.initializationPromise) {
            this.logger.log('info', `${logPrefix} Initialization already in progress. Returning existing promise.`);
            return this.initializationPromise;
        }

        this.logger.log('info', `${logPrefix} Starting new esbuild initialization process...`);
        this.publishStatus('initializing');

        this.initializationPromise = this._performInitialization(logPrefix);
        return this.initializationPromise;
    }

    public unload(): void {
        const logPrefix = `[EsbuildUnload]`;
        this.logger.log('info', `${logPrefix} Unloading and cleaning up resources.`);

        if (this.status === 'initialized') {
            this.logger.log('info', `${logPrefix} Stopping esbuild service.`);
            try {
                esbuild.stop();
            } catch (e: unknown) {
                this.logger.log('warn', `${logPrefix} Error stopping esbuild service during unload:`, e);
            }
        }

        this.initializationPromise = null;
        this.status = 'uninitialized';
        this.lastInitializationError = null;
        this.publishStatus('uninitialized');
        
        this.logger.log('info', `${logPrefix} EsbuildService cleanup complete.`);
    }

    // --- Private Implementation ---

    private async _performInitialization(logPrefix: string): Promise<void> {
        try {
            this.logger.log('verbose', `${logPrefix} Awaiting pre-compiled wasmModule...`);
            const wasmModule = await wasmModulePromise;
            this.logger.log('verbose', `${logPrefix} Wasm module received. Calling esbuild.initialize().`);

            // Initialize esbuild with the pre-compiled module.
            // This is the most robust and performant method.
            await esbuild.initialize({
                wasmModule: wasmModule,
                worker: true, // Use a web worker to avoid blocking the UI thread.
            });

            // --- Success ---
            this.status = 'initialized';
            this.lastInitializationError = null;
            this.logger.log('info', `${logPrefix} esbuild initialized successfully.`);
            this.publishStatus('initialized');

        } catch (error: unknown) {
            const initError = error instanceof EsbuildInitializationError ? error :
                              error instanceof PluginError ? new EsbuildInitializationError(createChainedMessage('Esbuild initialization failed.', error), error.cause || error, error.context) :
                              new EsbuildInitializationError(createChainedMessage('Unknown error during esbuild initialization.', error), error instanceof Error ? error : undefined);
            
            this.logger.log('error', `${logPrefix} Initialization failed:`, initError);
            
            this.lastInitializationError = initError;
            this.status = 'error';
            this.publishStatus('error', initError);
            
            // Reset promise to allow for another attempt
            this.initializationPromise = null;
            
            throw initError;
        }
    }

    private publishStatus(status: EsbuildStatus, error?: EsbuildInitializationError | null): void {
        this.status = status;
        this.eventBus.publish({ type: 'ESBUILD_STATUS_CHANGED', payload: { status, error } });
    }
}
